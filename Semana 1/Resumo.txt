Endiannes refere-se a ordenação dos bytes na memória conforme seu valor significativo(seu valor numerico), ou seja,
indica como os bytes de um dado multibyte são organizados, por exemplo:
0x1234 é um número em hexadecimal com 2 bytes, que representa 1*16^3 + 2*16^2 + 3*16^1 + 4*16^0 em decimal.
Na notação de Little Endian, o byte menos significativo vem primeiro, então ele seria escrito como 0x3412 
Em Big Endian, o byte mais significativo aparece primeiro, 0x1234
A maioria dos sistemas hoje são little endian, mas muito sistemas são bi-endian, podendo escolher, mas o padrão é little endian

O endereço da pilha começa de cima para baixo na memória, ela serve para alocação de variáveis locais e funções recursivas,
ela funciona seguindo o padrão LIFO, onde o primeiro elemento a ser retirado é o último que você colocou, 
semelhante a uma coluna/empilhamento de itens, 
pilha é feito automaticamente pelo processador, nativa do computador, gerenciado pelo complicador

Heap é o local onde ocorre a alocação dinâmica, caso coloque itens demais na pilha, ela acaba alcançando
o heap e sobrescrevendo os dados, dando o erro de Stack OverFlow, como um loop infinito.

1 byte = 8 bits, em hexadecimal, cada simbolo depois do x é equivalente a 1 byte na memória

Stdint.h é uma biblioteca que padroniza os bits dos tipos. O que traz portabilidade ao código 

Declare e inicializa os ponteiros com NULL

Variável armazena dado, ponteiro armazena endereço, no desreferenciamento, o *ponteiro é igual à variável

Por valor é a cópia, por referência é a original

1. argc:
É um inteiro que representa o número de argumentos passados ao programa no prompt de comando. 
Inclui o próprio nome do programa (que é sempre o primeiro argumento). 
argc é sempre um valor não negativo, o nome do programa já o faria incrementar. 

2. argv:
É um array de strings (ponteiros para caracteres). 
Cada elemento do array argv é uma string que representa um argumento passado ao programa. 
argv[0] sempre contém o nome do programa. 
Os argumentos subsequentes, como argv[1], argv[2], etc., são os argumentos passados pelo utilizador no prompt de comando. 
Os argumentos são separados por espaços ou tabulações na linha de comando

Mesmo sem usar o terminal, o argc e argv podem ser importantes:
- Pegar o nome do programa (argv[0])
- Construir funções genéricas que aceitam parâmetros (pode ser útil no futuro)
- Em programas reais (scripts, utilitários, ferramentas), é comum passar arquivos, flags, caminhos etc. via terminal

Um ponteiro de qualquer tipo numa arquitetura de 32 bits ocupa 4 bytes na memória, já numa arquitetura de 64 bits
ele ocupa 8 bytes de memória


Ponteiro de função é importante pois:

Chamar funções dinamicamente
int soma(int a, int b) { return a + b; }
int sub(int a, int b) { return a - b; }

int (*operacao)(int, int);  // ponteiro para função

operacao = soma;
printf("%d\n", operacao(5, 3));  // imprime 8

operacao = sub;
printf("%d\n", operacao(5, 3));  // imprime 2

///////////////////////////////////////////////////
Passar funções como argumento (callback)

void aplica(int x, int y, int (*f)(int, int)) {
    printf("Resultado: %d\n", f(x, y));
}

int mult(int a, int b) { return a * b; }

aplica(2, 4, mult);  // imprime: Resultado: 8

////////////////////////////////////////////////////
Tabelas de funções (vetores de ponteiros)

int somar(int x, int y) { return x + y; }
int multiplicar(int x, int y) { return x * y; }

int (*ops[])(int, int) = {somar, multiplicar};

int res = ops[1](3, 4);  // chama multiplicar(3, 4)

//////////////////////////////////////////////////////
Num struct, nem sempre o sizeof do struct vai ser igual a soma do sizeof dos seus campos,
isso ocorre devido ao padding, um espaço extra inserido pelo compilador para que haja o alinhamento
correto com a memória, esse padding basicamente é lixo de memória

typedef struct exemplo {
const char* nome;
uint8_t idade;
} exemplo;

nesse caso, o char* tem 8 bytes, o uint8_t tem 1 byte, que a soma dá 9, mas o sizeof de exemplos é 16
pois o padding vai tentar alinhar(encher até o múltiplo) do campo com maior bytes
o recomendado é fazer o struct do campo de maior bytes para o menor, de forma a evitar padding excesivo


malloc reserva espaço na memória, colocando qualquer coisa
calloc é um malloc, só que coloca 0 nos espaços reservados
realloc é um malloc que serve para aumentar a quantidade de espaço reservado, caso o malloc feito anteriormente não tenha sido suficiente
free libera a memória reservada (antes de usar o realloc deve dar free, e depois dele também)


Erros na utilização da memória
{
Falha de segmentação (segmentation fault): Acesso indevido na memória, ponteiros não inicializados ou não invalidados
Ex: referência para endereço inválido ou nulo

Estouro de pilha (stack overflow): A pilha sobrescreveu dados do heap
Ex: função recursiva em laço infinito

Memory Leak: Região de memória sem nenhum ponteiro

Buffer Overflow: Falta de controle nos limites de memória
}


