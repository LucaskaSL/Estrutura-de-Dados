EficiÃªncia Ã© otimizaÃ§Ã£o do tempo, reduÃ§Ã£o de recursos e uso de baixa potÃªncia
Quais sÃ£o os tipos de complexidade computacional?
-> Tempo: nÃºmero de passos executados
-> EspaÃ§o: tamanho da alocaÃ§Ã£o em memÃ³ria

void exemplo(uint32_t n) {
c1(); executa 1 vez
for(uint32_t i = 0; i < n; i++) chama n vezes
c2(); executa n vez
for(uint32_t j = 0; j < n; j++) chama n vezes
c3(); executa n vez
 for(uint32_t k = 0; k < n; k++) chama n vezes
c4(); executa n vez
} //por isso o tempo fica de c1 + c2*n + c3*n^2 + c4*n^3
nesse pseudo cÃ³digo, os cx() representam sub-rotinas, isto Ã©, operaÃ§Ãµes elementares ou constantes, 
usadas para anÃ¡lise de complexidade, placeholders que:
-> Executam em tempo fixo (independente do tamanho do input)
-> Podem ser qualquer coisa simples: somar dois nÃºmeros, acessar um vetor, fazer uma comparaÃ§Ã£o, trocar valores, etc

g(n) representa uma funÃ§Ã£o de crescimento que descreve o comportamento do tempo de execuÃ§Ã£o (ou uso de memÃ³ria)
naquele caso de exemplo(), g(n) = c*n^3, sempre pegando o maior expoente
A anÃ¡lise assintÃ³tica Ã© a verificaÃ§Ã£o do tempo de execuÃ§Ã£o baseado no nÃºmero de passos
O(g(n))	Limite superior: o algoritmo nÃ£o passa de g(n) exemplo(n) < g(n)
Î©(g(n))	Limite inferior: o algoritmo faz no mÃ­nimo g(n) exemplo(n) > g(n)
Î˜(g(n))	Limite preciso: o algoritmo faz exatamente g(n)  exemplo(n) = g(n)

Para algoritmos iterativos, ou seja, sem recursÃ£o, a anÃ¡lise assintÃ³tica ocorre:
identificar operaÃ§Ãµes primitivas;
identificar a quantidade de vezes que cada uma dessas primitivas Ã© executada;
Somar essas execuÃ§Ãµes.
VocÃª lembra quais sÃ£o as operaÃ§Ãµes primitivas? 
    - AvaliaÃ§Ã£o de expressÃµes booleanas;
    - OperaÃ§Ãµes matemÃ¡ticas;
    - Retorno de mÃ©todos;
    - AtribuiÃ§Ã£o;
    - Acesso Ã  variÃ¡veis e posiÃ§Ãµes arbitrÃ¡rias de um array

No algoritmo iterativo, quando ele nÃ£o depende da entrada, sempre serÃ¡ Î˜(â€¦),
Caso dependa da entrada, como num algoritmo de ordenaÃ§Ã£o(como a lista estava inicialmente) varia entre O, Î˜, Î©


MÃ©todo Mestre:
Verifique o grau (expoente) de ğ‘“(ğ‘›)
f(n) e compare com log(de a)(na base b)
ğŸ”¸ Se o grau de ğ‘“(ğ‘›) for menor, Ã© Caso 1 (recursÃ£o domina).
T(n) = Î˜(n^log(de a)(na base b))
ğŸ”¸ Se for igual, Ã© Caso 2 (empate).
T(n) = Î˜(n^log(de a)(na base b) * log n), se tiver algum log na T(n), simplesmente eleve o log n de Î˜ Ã  quantidade de
logs em T(n) + 1
ğŸ”¸ Se for maior, Ã© Caso 3 (trabalho externo domina, verifica regularidade).
 T(n) = Î˜(f(n))